<template>
  <div class="vui-overlayer">
    <transition name="vui-fade" @after-enter="onAfterEnter">
      <div
        v-show="value"
        :class="['vui-overlayer__layer', { 'vui-overlayer--hide': hide }]"
        :style="{ zIndex }"
        @click.self="onClick"
        @touchmove.self="$event.preventDefault()"
      ></div>
    </transition>
    <slot></slot>
  </div>
</template>

<script lang="ts">
import { Vue, Component, Prop, Watch } from 'vue-property-decorator'
import { zIndex, update } from '@/utils/store'

const layerList: any[] = []

@Component({
  name: 'VuiOverlayer'
})
export default class VComponent extends Vue {
  zIndex = zIndex
  hide = false
  // 记录是否点击了蒙层
  clicked = false

  @Prop({
    default: false
  })
  readonly value!: boolean

  // @Prop({
  //   default() {
  //     return zIndex
  //   }
  // })
  // readonly zIndex!: number

  // 打开蒙层时是否pushState，如果是的话返回时关闭蒙层而不是页面后退
  @Prop({
    default: true
  })
  readonly pushState!: boolean

  // 点击蒙层是否自动关闭
  @Prop({
    default: true
  })
  readonly clickClose!: boolean

  // 阻止点击、back关闭
  @Prop({
    default: false
  })
  readonly preventClose!: boolean

  @Watch('value', {
    immediate: true
  })
  onValueChange() {
    if (this.value) {
      this.zIndex = zIndex
      update({ zIndex: zIndex + 1 })
      // 如果之前有显示蒙层，则隐藏当前蒙层
      this.hide = !!layerList.length

      // 将之前显示的蒙层zIndex加1
      if (layerList.length) {
        layerList[layerList.length - 1].zIndex++
      }

      layerList.push(this)
    } else {
      layerList.pop()
    }

    if (this.pushState) {
      if (this.value) {
        window.history.pushState(
          {
            [this.$options.name!]: true
          },
          ''
        )
        window.addEventListener('popstate', this.onPopState)
      } else if (window.history.state && window.history.state[this.$options.name!]) {
        window.history.back()
      }
    }
  }

  onAfterEnter() {
    // 显示当前蒙层并隐藏之前显示的蒙层
    this.hide = false

    if (layerList.length > 1) {
      layerList[layerList.length - 1].hide = true
      layerList[layerList.length - 1].zIndex--
    }
  }

  onClick() {
    if (this.clickClose && !this.preventClose) {
      if (this.pushState) {
        this.clicked = true
        window.history.back()
      } else {
        this.$emit('input', false)
      }
    }

    // 确保history.forward()真正执行完成
    setTimeout(() => {
      this.$emit('click', this.preventClose)
    }, 50)
  }

  onPopState({ state }: PopStateEvent) {
    if (!state || !state[this.$options.name!]) {
      // 外部主动关闭或者不阻止内部关闭
      if (!this.value || !this.preventClose) {
        window.removeEventListener('popstate', this.onPopState)
        this.$emit('input', false)
      } else {
        window.history.forward()
      }
      // 非外部主动关闭且非click关闭
      this.value &&
        this.clicked &&
        setTimeout(() => {
          // 确保history.forward()真正执行完成
          this.$emit('back', this.preventClose)
        }, 50)
      this.clicked = false
    }
  }
}
</script>
